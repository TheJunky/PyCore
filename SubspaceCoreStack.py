# Copyright (c) 2010 cycad <cycad@zetasquad.com>. All rights reserved.

from logging import DEBUG,INFO,ERROR,CRITICAL
import socket
import sys
import struct 
import random 
import traceback
import SubspaceEncryption
import time
import math
import select
from SubspaceFileChecksum import FileChecksum


def GetTickCountHs():
	"""Tick count in hundreths of a second."""
	return math.trunc(time.clock() * 100) & 0xFFFFFFFF


def TickDiff(now, base):
	"""Returns the difference between two 32-bit tick counts."""
	return (now - base) & 0xFFFFFFFF


PRIORITY_HIGH = 0	# for sending a high priority packet, like position updates or ack messages
PRIORITY_NORMAL = 1	# for sending normal priority packets

MAX_PACKET = 512	# the maximum packet size

RELIABLE_RETRANSMIT_INTERVAL = 50	# in hundreths of seconds

EVENT_TICK_INTERVAL = 10 # how often EVENT_TICK happens, in hs, backed by an accumulator
EVENT_INTERNAL_CORE_PERIODIC_INTERVAL = 10 # not backed by an accumulator

NO_PACKET_RECEIVED_TIMEOUT_INTERVAL = 1500 # after 15 seconds without receiving data, disconnect


# core events
EVENT_GAME_PACKET_RECEIVED = 1
EVENT_TICK = 2
EVENT_DISCONNECT = 3
	
class CoreEvent:
	"""Represents an event generated by the Core."""
	def __init__(self, type):
		self.type = type

class QueuedPacket:
	"""Represents a packet that is in queue to be sent on the network."""
	def __init__(self, data, reliable=False):
		self.data = data
		self.reliable = reliable
		if self.totalPacketSize() > MAX_PACKET:
			raise Exception("Packet has a size greater than the maximum allowed: %d" % self.totalPacketSize())
	
	def totalPacketSize(self):
		"""Compute the total packed size, including the size of the reliable header if necessary."""
		if self.reliable: return len(self.data) + 6
		else: return len(self.data)

class CoreStack:
	"""The core stack."""
	def __init__(self, debug=False,logger=None):
		self.__debug = debug
		self.logger = logger
		
		
		self.__socket = None
		self.__crypto = None # initialized after servers key is received. once set, encryption is done
		self.__packet_queues = [[], []]	# list containing QueuedPacket objects
		self.__reliable_messages_in_transit = { } # ackid : [packet, last transmit tick]   a list is used because it needs to be assigned (updating tick count) while the dictionary has an open iterator
		self.__incoming_reliable_packets = [] # (ack_id, packet) reliable messages that were received out of order, packet does not include the reliable header
		self.__event_list = [] # the list of pending CoreEvent objects
		
		self.__last_packet_received_tick = GetTickCountHs()
		
		# the packet handler functions
		self.__packet_handlers = {
			0x03 : self.__handleReliableMessage,
			0x04 : self.__handleAckPacket,
			0x05 : self.__handleSyncRequestPacket,
			0x06 : self.__handleSyncResponsePacket,
			0x07 : self.__handleDisconnectPacket,
			0x08 : self.__handleChunk,
			0x09 : self.__handleChunkEnd,
			0x0A : self.__handleHugeChunk,
			0x0D : self.__handleDisconnectPacket,	#xxx we could parse the reason out of this
			0x0E : self.__handleClusterPacket,
		}
		
		# the list of incoming chunk data that gets concatenated and then handled
		self.__chunk_list = None
		self.__huge_chunk_data = None
		
		#for the external loop will be set to false if we disconnect from server
		#ie !stopbot
		self.reconnect = True 
	
	
	def resetState(self):#for recop
		self.__socket = None
		self.__crypto = None # initialized after servers key is received. once set, encryption is done
		self.__packet_queues = [[], []]	# list containing QueuedPacket objects
		self.__reliable_messages_in_transit = { } # ackid : [packet, last transmit tick]   a list is used because it needs to be assigned (updating tick count) while the dictionary has an open iterator
		self.__incoming_reliable_packets = [] # (ack_id, packet) reliable messages that were received out of order, packet does not include the reliable header
		self.__event_list = [] # the list of pending CoreEvent objects
		
	def __log(self,level,message):
		if self.logger:
			self.logger.log(level,message)
		else:
			print (message)
	
		
	def __addPendingEvent(self, core_event):
		"""Adds CoreEvent to the list for handling."""
		self.__event_list.append(core_event)
		
	def connectToServer(self, server, port,newconn=1):
		"""Connect to the server, otherwise raise an exception."""

		self.__total_packets_sent = 0
		self.__total_packets_received = 0
		self.__next_outgoing_ack_id = 0
		self.__next_incoming_ack_id = 0
		self.__last_sync_response_received_tick = GetTickCountHs()
		
		self.__event_tick_tick_accumulator = 0
		self.__last_wait_for_event_call_tick = GetTickCountHs()
		self.__last_core_periodic_event_tick = GetTickCountHs()

		self.__server = str(server)
		self.__port = int(port)
		self.__socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
		self.__socket.connect((server, port))
		self.__socket.setblocking(False) #changed for jython support doesnt seem to affect python
		#self.__socket.settimeout(.01)
		self.__timeout_interval = 0.01

			
		STATE_NONE = 0
		STATE_CHALLENGE_RECEIVED = 1
		STATE_CONNECTED = 2
		
		client_key = (-random.randrange(1, sys.maxint))
		server_challenge = 0
		
		
		self.fc = FileChecksum()
		self.fc.generateChecksumArray(0)
		
		state = STATE_NONE
		timeouts = 0
		while state != STATE_CONNECTED:
			if timeouts > 3:
				break
			
			# send queueing the packets directly is done here because
			# handshake packets are special
			if state == STATE_NONE:
				# send handshake initiation packet
				self.queuePacket(struct.pack("<BBIH", 0x00, 0x01, client_key & 0xFFFFFFFF, 0x0001))
			elif state == STATE_CHALLENGE_RECEIVED:
				# respond with server challenge
				self.queuePacket(struct.pack("<BBII", 0x00, 0x06, server_challenge & 0xFFFFFFFF, GetTickCountHs()))
			
			# write sent packets to the network
			self.flushOutboundQueues()
			
			# read raw packet is used here because the packets during handshake
			# are a little bit special (such as the 0x02 type containing key data)
			packet = self.__readRawPacket(2)
			if packet is None:
				timeouts += 1
				continue
			
			try:
				game_type, core_type = struct.unpack_from("<BB", packet)
				
				# default to bad state, unless we get an expected packet
				state = STATE_NONE
				if game_type == 0x00:
					if core_type == 0x05:	# response to __sendClientKey()
						server_challenge, = struct.unpack_from("<i", packet, 2)
						state = STATE_CHALLENGE_RECEIVED
					elif core_type == 0x02:
						# success
						server_key, = struct.unpack_from("<i", packet, 2)
						self.__crypto = SubspaceEncryption.SubspaceEncryption(client_key, server_key)
						state = STATE_CONNECTED
						break
			except struct.error:
				pass
				
		if state != STATE_CONNECTED:
			self.__log(CRITICAL,"Unable to connect to server")
			self.__connected = False
		else:
			self.__connected = True
	
		
	def queuePacket(self, data, reliable=False, priority=PRIORITY_NORMAL):
		"""Queue a packet to be sent."""
		size = len(data)
		psize = size + (6 if reliable else 0)
		if psize < MAX_PACKET:
			self.__packet_queues[priority].append(QueuedPacket(data, reliable))
		else:
			if size < (MAX_PACKET*100):
				#print "chunk total size:" + str(len(data))
				MAX_CHUNK = MAX_PACKET - 8# 6 for reliable header + 2 for packet header
				while(len(data)> 0):
					chunk_size = min(MAX_CHUNK,len(data))
					remaining = len(data)- chunk_size
					if remaining >0:
						packet = struct.pack("<BB",0x00,0x08)
						#print "Headpacket_size: %d Remaining Data:%d" % (chunk_size, remaining)  
					else:
						packet = struct.pack("<BB",0x00,0x09) 
						#print "Tailpacket_size: %d Remaining Data:%d" % (chunk_size, remaining) 
					packet += data[0:chunk_size-1]
					data = data[chunk_size:]
					self.__packet_queues[priority].append(QueuedPacket(packet, True))	
			else:
				#dont think this works when i putfile it seems to fail if it gets so big as to use huge chunk
					offset =0 
					print "huge chunk total size:" + str(size)
					MAX_CHUNK = MAX_PACKET - 12# 6 for reliable header + 6 for packet header
					
					while(len(data)> 0):
						chunk_size = min(MAX_CHUNK,len(data))
						packet = struct.pack("<BBI",0x00,0x0a,size) 
						packet += data[0:chunk_size-1]
						data = data[chunk_size:]
						print "packet_size: %d Remaining Data:%d" % (chunk_size, len(data))
						self.__packet_queues[priority].append(QueuedPacket(packet, True)) 
	
	def __generateNextOutboundPacket(self):
		"""Extract packets from queues and return a buffer containing the next outbound packet
		that is to be sent on the network, if a packet can be built.
		"""
		h = self.__packet_queues[PRIORITY_HIGH]
		n = self.__packet_queues[PRIORITY_NORMAL]
		
		if len(h) == 0 and len(n) == 0:
			return None
				
		# determine which packets can be clustered, if any
		clusterable_packets = 0
		try:
			for packet_list in [h, n]:
				for outgoing_packet in packet_list:
					if outgoing_packet.totalPacketSize() > 255:
						raise StopIteration()
					clusterable_packets += 1
		except StopIteration:
			pass
		
		data = None
		if clusterable_packets > 1:
			data = struct.pack("<BB", 0x00, 0x0E)
			
			reliable_allowed = True
			for packet_list in [h, n]:
				i = 0
				for p in packet_list[:]:
					if p.totalPacketSize() <= 255 and len(data) + p.totalPacketSize() + 1 <= MAX_PACKET: #plus 1 is for the data length in cluster
						if p.reliable:
							#send reliable packet, can be disallowed due to ordering concerns
							if reliable_allowed:
								packet = struct.pack("<BBBI", p.totalPacketSize(), 0x00, 0x03, self.__next_outgoing_ack_id & 0xFFFFFFFF) + p.data
								
								# store off packet[1:] here so when its retransmitted, it doesnt re-append the 'size' field
								# since only the data should be resent
								self.__reliable_messages_in_transit[self.__next_outgoing_ack_id] = [packet[1:], GetTickCountHs()]
								self.__next_outgoing_ack_id += 1
								data += packet
								
								packet_list[i] = None
						else:
							# send an unreliable packet
							data += struct.pack('<B', p.totalPacketSize()) + p.data
							packet_list[i] = None
					elif p.reliable:
						# this packet wont fit and it is reliable, so dont allow following
						# reliable packets to be sent, because these need to be sent in order
						reliable_allowed = False
					i += 1
			
			# remove None entries
			# opt: should these be   self.__packet_queues[PRIORITY_Xxx][:] = ...   ?
			self.__packet_queues[PRIORITY_HIGH] = [x for x in h if x is not None]
			self.__packet_queues[PRIORITY_NORMAL] = [x for x in n if x is not None]
			
		else:
			# a single, non-cluster packet is being sent
			if len(h): p = h.pop(0)
			else: p = n.pop(0)
				
			data = p.data
			
			if p.reliable:
				# send packet with the reliable header prepended
				data = struct.pack("<BBI", 0x00, 0x03, self.__next_outgoing_ack_id & 0xFFFFFFFF) + data
				self.__reliable_messages_in_transit[self.__next_outgoing_ack_id] = [data, GetTickCountHs()]
				self.__next_outgoing_ack_id += 1
		
		return data
	
	def flushOutboundQueues(self):
		"""Flush outbound packet queues."""
		while 1:
			if len(self.__packet_queues[PRIORITY_HIGH]) == 0 and len(self.__packet_queues[PRIORITY_NORMAL]) == 0:
				break
			# check to make sure outbound socket is writable
			rlist, wlist, xlist = select.select([], [self.__socket], [], 0)
			if len(wlist) == 0: break
		
			packet = self.__generateNextOutboundPacket()
			if packet:
				self.__sendRawPacket(packet)
				
	def __queueAckPacket(self, ack_id):
		"""Queue an ack packet."""
		self.queuePacket(struct.pack("<BBI", 0x00, 0x04, ack_id & 0xFFFFFFFF))
	
	def __queueDisconnectPacket(self):
		"""Queue a disconnect packet."""
		self.queuePacket(struct.pack("<BB", 0x00, 0x07))
	
	def disconnectFromServer(self):
		"""Disconnect from the server."""
		self.__queueDisconnectPacket()
		self.__addPendingEvent(CoreEvent(EVENT_DISCONNECT))
		self.reconnect = False
	
	def shouldReconnect(self):
		return self.reconnect
		
	def __handleReliableMessage(self, packet):
		"""Handle an incoming reliable message."""
		# this could be cleaner by adding to the incoming list, then processing lists
		zero, core_type, ack_id = struct.unpack_from("<BBI", packet)
		
		self.__queueAckPacket(ack_id)
		
		if ack_id == self.__next_incoming_ack_id:
			self.__next_incoming_ack_id += 1
			self.__processIncomingPacket(packet[6:])
			
			loop_again = True
			while loop_again:
				loop_again = False
				index = 0
				for ack_packet_tuple in self.__incoming_reliable_packets:
					if ack_packet_tuple[0] == self.__next_incoming_ack_id:
						self.__incoming_reliable_packets.pop(index)
						self.__next_incoming_ack_id += 1
						self.__processIncomingPacket(ack_packet_tuple[1])
						loop_again = True
						break
					index += 1
			
		elif ack_id > self.__next_incoming_ack_id:
			self.__incoming_reliable_packets.append((ack_id, packet[6:]))
	
	def __handleChunk(self, packet):
		if self.__chunk_list is None:
			self.__chunk_list = []
			#print "small chunk type: " + packet.encode('hex')
		self.__chunk_list.append(packet[2:])
	
	def __handleChunkEnd(self, packet):
		if self.__chunk_list:
			self.__chunk_list.append(packet[2:])
			self.__processIncomingPacket(''.join(self.__chunk_list))
			self.__chunk_list = None
	
	#added by junky
	def __handleHugeChunk(self,packet):
		type,type2, total_size = struct.unpack_from("<BBI",packet)
		if(self.__huge_chunk_data == None): #new chunk
			self.__huge_chunk_data = packet[6:]
			print "huge chunk type: " + self.__huge_chunk_data.encode('hex')
		else:
			self.__huge_chunk_data += packet[6:] 
			
		if( len(self.__huge_chunk_data) == total_size): #packet complete
			self.__processIncomingPacket(self.__huge_chunk_data[:])
			self.__huge_chunk_data = None


			
			
	
	def waitForEvent(self):
		"""Wait for an event to occur.  If no event is immediately available this
		call blocks.  Must be called frequently for good performance."""
		while self.__connected:
			self.__processIncomingPackets()
			self.flushOutboundQueues()
			
			# process tick event if necessary
			now = GetTickCountHs()
			self.__event_tick_tick_accumulator += now - self.__last_wait_for_event_call_tick
			self.__last_wait_for_event_call_tick = now
			while self.__event_tick_tick_accumulator > EVENT_TICK_INTERVAL:
				self.__addPendingEvent(CoreEvent(EVENT_TICK))
				self.__event_tick_tick_accumulator -= EVENT_TICK_INTERVAL
			
			# create internal periodic core event
			if TickDiff(now,  self.__last_core_periodic_event_tick) > EVENT_INTERNAL_CORE_PERIODIC_INTERVAL:
				self.__corePeriodicEvent()
				self.__last_core_periodic_event_tick = now
			
			# process pending events first
			if len(self.__event_list) > 0:
				# preprocess the event
				event = self.__event_list.pop(0)
				if event.type == EVENT_DISCONNECT:
						self.__connected = False
				return event
			
			# nothing left to do, wait on an event
			timeout = float(EVENT_TICK_INTERVAL - self.__event_tick_tick_accumulator) / 100
			# if there are no packets to be sent, just wait for a read
			# otherwise wait for a read or the outbound socket to be writable
			if len(self.__packet_queues[PRIORITY_HIGH]) == 0 and len(self.__packet_queues[PRIORITY_NORMAL]) == 0:
				select.select([self.__socket], [], [], timeout)
			else:
				select.select([self.__socket], [self.__socket], [], timeout)

	def __processIncomingPackets(self):
		"""Process all incoming packets."""
		# process incoming packets, if any exist
		while True:
			packet = self.__readRawPacket(0)
			if packet is None: break
			self.__processIncomingPacket(packet)
			
	def __corePeriodicEvent(self):
		"""This is called every 100ms"""
		# requeue reliable messages that havent been acked
		now = GetTickCountHs()
		for ack_id, packet_last_transmit_tick_list in self.__reliable_messages_in_transit.iteritems():
			if TickDiff(now, packet_last_transmit_tick_list[1]) > RELIABLE_RETRANSMIT_INTERVAL:
				self.queuePacket(packet_last_transmit_tick_list[0], False, PRIORITY_HIGH)
				packet_last_transmit_tick_list[1] = now
		
		if TickDiff(now, self.__last_packet_received_tick) >= NO_PACKET_RECEIVED_TIMEOUT_INTERVAL:
			self.__addPendingEvent(CoreEvent(EVENT_DISCONNECT))
	
	def __handleClusterPacket(self, packet):
		packet = packet[2:]
		while len(packet):
			data_len, = struct.unpack_from("<B", packet)
			self.__processIncomingPacket(packet[1:data_len + 1])
			packet = packet[data_len + 1:]
	
	def __handleDisconnectPacket(self, packet):
		self.__addPendingEvent(CoreEvent(EVENT_DISCONNECT))
	
	def __handleSyncRequestPacket(self, packet):
		self.__queueSyncResponse()
	
	def __handleSyncResponsePacket(self, packet):
		self.__last_sync_response_received_tick = GetTickCountHs()
		
	def __handleAckPacket(self, packet):
		zero, type, ack_id = struct.unpack_from("<BBI", packet)
		self.__reliable_messages_in_transit.pop(ack_id, None)
		
	def __processIncomingPacket(self, packet):
		# process the incoming packet, etc
		try:
			type, = struct.unpack_from("<B", packet)
			if type == 0x00:
				# core packet handlers
				type, = struct.unpack_from("<B", packet, 1)
				if self.__debug:
					self.__log(DEBUG, "Handling Core Type: 0x%02X" % type)
					
				handler = self.__packet_handlers.get(type, None)
				if handler:
					handler(packet)
				else:
					self.__log(INFO,"wtf corestack type %i not handled"%(type,))
			else:
				if self.__debug:
					self.__log(DEBUG, "Handling Game Type: 0x%02X" % type)
				event = CoreEvent(EVENT_GAME_PACKET_RECEIVED)
				event.packet = packet
				self.__addPendingEvent(event)
			
		except (IndexError, struct.error):
			self.__log(CRITICAL, "Error in packet processing")
			self.__log(CRITICAL, "Packet data: " + packet.encode('hex'))
			formatted_lines = traceback.format_exc().splitlines()
			for l in formatted_lines:
				self.__log(DEBUG,l)
			
	def __readRawPacket(self, timeout):
		"""Read a raw packet on the network, optionally blocking on the socket."""
		rlist, wlist, xlist = select.select([self.__socket], [], [], timeout)
		if len(rlist) == 0:
			time.sleep(0.01)
			return None

#		try:
#			if self.__timeout_interval != timeout:
#				self.__timeout_interval = timeout
#				self.__socket.settimeout(self.__timeout_interval)
#			packet = self.__socket.recv(MAX_PACKET)
#		except socket.timeout as e:
#			#self.logger.info("timeout")
#			return
		packet = rlist[0].recv(MAX_PACKET)
	
		self.__total_packets_received += 1
		
		# decrypt the packet
		if self.__crypto:
			try:
				type, = struct.unpack_from("<B", packet)
				begin_offset = 1
				if type == 0x00:
					begin_offset = 2
				packet = packet[:begin_offset] + self.__crypto.decryptData(packet[begin_offset:])
					
			except (IndexError, struct.error):
				packet = None
		
		if packet:
			if self.__debug:
				self.__log(DEBUG, "Read:" + packet.encode('hex'))
		
			self.__last_packet_received_tick = GetTickCountHs()
			
		return packet
	
	def _queueSyncRequest(self):
		self.queuePacket(struct.pack("<BBIII", 0x00, 0x05, GetTickCountHs(), self.__total_packets_sent & 0xFFFFFFFF, self.__total_packets_received & 0xFFFFFFFF), priority=PRIORITY_HIGH)
	
	def __queueSyncResponse(self):
		self.queuePacket(struct.pack("<BBII", 0x00, 0x06, GetTickCountHs(), TickDiff(GetTickCountHs(), self.__last_sync_response_received_tick)), priority=PRIORITY_HIGH)
	
	#def __handleSyncResponsePacket(self, packet):
	#	# packet contents are irrelevant
	#	self.__last_sync_response_received_tick = GetTickCountHs()
	
	def __queueAckMessage(self, ack_id):
		self.queuePacket(struct.pack("<BBI", 0x00, 0x03, ack_id & 0xFFFFFFFF), priority=PRIORITY_HIGH)
	
	def __sendRawPacket(self, packet):
		if self.__debug:
			self.__log(DEBUG, "Sent:" + packet.encode('hex'))
			
		if self.__crypto:
			begin_offset = 1
			if ord(packet[0]) == 0x00:
				begin_offset = 2
			
			packet = packet[:begin_offset] + self.__crypto.encryptData(packet[begin_offset:])
			
		self.__socket.sendall(packet)
		self.__total_packets_sent += 1
